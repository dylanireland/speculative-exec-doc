/**
 * Used to represent account keypairs
 * @packageDocumentation
 */
/// <reference types="node" />
import { CLPublicKey } from './CLValue';
import { SignatureAlgorithm } from './types';
export { SignatureAlgorithm } from './types';
export interface SignKeyPair {
    publicKey: Uint8Array;
    secretKey: Uint8Array;
}
export declare const getKeysFromHexPrivKey: (key: string, variant: SignatureAlgorithm) => AsymmetricKey;
/**
 * Reads in a base64 private key, ignoring the header: `-----BEGIN PUBLIC KEY-----`
 * and footer: `-----END PUBLIC KEY-----`
 * @param {string} content A .pem private key string with a header and footer
 * @returns A base64 private key as a `Uint8Array`
 * @remarks
 * If the provided base64 `content` string does not include a header/footer,
 * it will pass through this function unaffected
 * @example
 * Example PEM:
 *
 * ```
 * -----BEGIN PUBLIC KEY-----\r\n
 * MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEj1fgdbpNbt06EY/8C+wbBXq6VvG+vCVD\r\n
 * Nl74LvVAmXfpdzCWFKbdrnIlX3EFDxkd9qpk35F/kLcqV3rDn/u3dg==\r\n
 * -----END PUBLIC KEY-----\r\n
 * ```
 */
export declare function readBase64WithPEM(content: string): Uint8Array;
export declare const validateSignature: (msg: Uint8Array, signature: Uint8Array, pk: CLPublicKey) => boolean;
/** Public/private keypair object for representing an account */
export declare abstract class AsymmetricKey {
    readonly publicKey: CLPublicKey;
    readonly privateKey: Uint8Array;
    readonly signatureAlgorithm: SignatureAlgorithm;
    /**
     * Constructs an `AsymmetricKey` inherited object
     * @param {Uint8Array} publicKey An account's public key as a byte array
     * @param {Uint8Array} privateKey An account's private key as a byte array
     * @param {SignatureAlgorithm} signatureAlgorithm The signature algorithm of the key. Currently supported are Ed25519 and Secp256k1
     */
    constructor(publicKey: Uint8Array, privateKey: Uint8Array, signatureAlgorithm: SignatureAlgorithm);
    /**
     * Computes the blake2b account hash of the public key
     * @returns The account hash as a byte array
     */
    accountHash(): Uint8Array;
    /**
     * Gets the hexadecimal public key of the account
     * @returns The public key of the `AsymmetricKey` as a hexadecimal string
     */
    accountHex(): string;
    /**
     * Inserts the provided `content` and `tag` into a .pem compliant string
     * @param tag The tag inserted on the END line
     * @param content The base-64 PEM compliant private key
     */
    protected toPem(tag: string, content: string): string;
    /**
     * Export the public key encoded as a .pem
     */
    abstract exportPublicKeyInPem(): string;
    /**
     * Export the private key encoded as a .pem
     */
    abstract exportPrivateKeyInPem(): string;
    /**
     * Sign a message using this `AsymmetricKey`'s private key
     * @param {Uint8Array} msg The message to be signed, as a byte array
     * @returns A byte array containing the signed message
     */
    abstract sign(msg: Uint8Array): Uint8Array;
    /**
     * Validate the signature by comparing it to the provided message
     * @param {Uint8Array} signature The signature as a byte array
     * @param {Uint8Array} msg The original message to be validated
     * @returns `true` if the signature is valid, `false` otherwise
     */
    abstract verify(signature: Uint8Array, msg: Uint8Array): boolean;
}
/**
 * Ed25519 variant of `AsymmetricKey`
 * @remarks
 * Based on SignatureAlgorithm.scala
 * @see [Documentation](https://docs.casper.network/concepts/accounts-and-keys/#eddsa-keys)
 */
export declare class Ed25519 extends AsymmetricKey {
    /**
     * Constructs a new Ed25519 object from a `SignKeyPair`
     * @param {SignKeyPair} keyPair An object containing the keys "publicKey" and "secretKey" with corresponding `ByteArray` values
     */
    constructor(keyPair: SignKeyPair);
    /**
     * Generates a new Ed25519 key pair
     * @returns A new `Ed25519` object
     */
    static new(): Ed25519;
    /**
     * Generate the accountHex for the Ed25519 public key
     * @param publicKey
     */
    static accountHex(publicKey: Uint8Array): string;
    /**
     * Parse the key pair from a public key file and the corresponding private key file
     * @param {string} publicKeyPath Path of public key file
     * @param {string} privateKeyPath Path of private key file
     * @returns A new `AsymmetricKey`
     */
    static parseKeyFiles(publicKeyPath: string, privateKeyPath: string): AsymmetricKey;
    /**
     * Generates the account hash of a Ed25519 public key
     * @param {Uint8Array} publicKey An Ed25519 public key
     * @returns The blake2b account hash of the public key
     */
    static accountHash(publicKey: Uint8Array): Uint8Array;
    /**
     * Construct a keypair from a public key and corresponding private key
     * @param {Uint8Array} publicKey The public key of an Ed25519 account
     * @param {Uint8Array} privateKey The private key of the same Ed25519 account
     * @returns A new `Ed25519` keypair
     */
    static parseKeyPair(publicKey: Uint8Array, privateKey: Uint8Array): Ed25519;
    static parsePrivateKeyFile(path: string): Uint8Array;
    /**
     * Parses a file containing an Ed25519 public key
     * @param {string} path The path to the public key file
     * @returns A `Uint8Array` typed representation of the public key
     * @see {@link Ed25519.parsePublicKey}
     */
    static parsePublicKeyFile(path: string): Uint8Array;
    /**
     * Parses a byte array containing an Ed25519 private key
     * @param {Uint8Array} bytes A private key as a byte array
     * @returns A validated byte array containing the provided Ed25519 private key
     * @see {@link Ed25519.parseKey}
     */
    static parsePrivateKey(bytes: Uint8Array): Uint8Array | Buffer;
    /**
     * Parses a byte array containing an Ed25519 public key
     * @param {Uint8Array} bytes A public key in bytes
     * @returns A validated byte array containing the provided Ed25519 public key
     * @see {@link Ed25519.parseKey}
     */
    static parsePublicKey(bytes: Uint8Array): Uint8Array | Buffer;
    /**
     * Calls global {@link readBase64WithPEM} and returns the result
     * @param {string} content A .pem private key string with a header and footer
     * @returns The result of global `readBase64WithPEM`
     * @see {@link readBase64WithPEM}
     */
    static readBase64WithPEM(content: string): Uint8Array;
    /**
     * Read the Base64 content of a file, ignoring PEM frames
     * @param {string} path The path to the PEM file
     * @returns The result of {@link Ed25519.readBase64WithPEM} after reading in the content as a `string` with `fs`
     */
    private static readBase64File;
    /**
     * Parses and validates a key in a certain range "from" to "to"
     * @param {Uint8Array} bytes The key to be parsed and validated
     * @param {number} from The starting index from which to parse the key
     * @param {number} to The ending index from which to parse the key
     * @returns The parsed key
     * @throws `Error` if the key is of an unexpected length
     */
    private static parseKey;
    /**
     * Convert this instance's private key to PEM format
     * @returns A PEM compliant string containing this instance's private key
     * @see {@link AsymmetricKey.toPem}
     */
    exportPrivateKeyInPem(): string;
    /**
     * Convert this instance's public key to PEM format
     * @returns A PEM compliant string containing this instance's public key
     * @see {@link AsymmetricKey.toPem}
     */
    exportPublicKeyInPem(): string;
    /**
     * Sign a message by using this instance's keypair
     * @param {Uint8Array} msg The message to be signed, as a byte array
     * @returns `Uint8Array` typed signature of the provided `msg`
     */
    sign(msg: Uint8Array): Uint8Array;
    /**
     * Verifies a signature given the signature and the original message
     * @param {Uint8Array} signature The signed message as a byte array
     * @param {Uint8Array} msg The original message as a byte array
     * @returns 'true' if the message if valid, `false` otherwise
     */
    verify(signature: Uint8Array, msg: Uint8Array): boolean;
    /**
     * Derive a public key from private key or seed phrase
     * @param {Uint8Array} privateKey The private key or seed phrase from which to derive the public key
     * @returns A `Uint8Array` public key generated deterministically from the provided private key or seed phrase
     * @remarks Both secret keys and seed phrases may be used to derive the public key
     */
    static privateToPublicKey(privateKey: Uint8Array): Uint8Array;
    /**
     * Restore Ed25519 keyPair from private key file
     * @param {string} privateKeyPath The path to the private key file
     * @returns An Ed25519 `AsymmetricKey`
     * @see {@link Ed25519.parsePrivateKeyFile}
     * @see {@link Ed25519.privateToPublicKey}
     * @see {@link Ed25519.parseKeyPair}
     */
    static loadKeyPairFromPrivateFile(privateKeyPath: string): Ed25519;
}
/**
 * Secp256k1 variant of `AsymmetricKey`
 * @privateRemarks
 * Orignated from [Secp256k1](https://en.bitcoin.it/wiki/Secp256k1) to support Ethereum keys on the Casper.
 * @see [Documentation](https://docs.casper.network/concepts/accounts-and-keys/#ethereum-keys)
 */
export declare class Secp256K1 extends AsymmetricKey {
    /**
     * Constructs a new Secp256K1 object from a public key and a private key
     * @param {Uint8Array} publicKey A secp256k1 public key
     * @param {Uint8Array} privateKey A secp256k1 private key
     */
    constructor(publicKey: Uint8Array, privateKey: Uint8Array);
    /**
     * Generate a new pseudorandom Secp256k1 key pair
     * @returns A new `Secp256K1` object
     */
    static new(): Secp256K1;
    /**
     * Parse the key pair from a public key file and the corresponding private key file
     * @param {string} publicKeyPath Path of public key file
     * @param {string} privateKeyPath Path of private key file
     * @returns A new `Secp256K1` object
     */
    static parseKeyFiles(publicKeyPath: string, privateKeyPath: string): AsymmetricKey;
    /**
     * Generates the account hash of a secp256k1 public key
     * @param {Uint8Array} publicKey A secp256k1 public key
     * @returns The blake2b account hash of the public key
     */
    static accountHash(publicKey: Uint8Array): Uint8Array;
    /**
     * Converts a `Uint8Array` public key to hexadecimal format
     * @param publicKey
     * @remarks
     * The returned public key hex will be prefixed with a "02" to indicate that it is of the secp256k1 variety
     */
    static accountHex(publicKey: Uint8Array): string;
    /**
     * Construct a keypair from a public key and corresponding private key
     * @param {Uint8Array} publicKey The public key of a secp256k1 account
     * @param {Uint8Array} privateKey The private key of the same secp256k1 account
     * @returns A new `AsymmetricKey` keypair
     */
    static parseKeyPair(publicKey: Uint8Array, privateKey: Uint8Array, originalFormat: 'raw' | 'der'): AsymmetricKey;
    /**
     * Parses a file containing a secp256k1 private key
     * @param {string} path The path to the private key file
     * @returns A `Uint8Array` typed representation of the private key
     * @see {@link Secp256K1.parsePrivateKey}
     */
    static parsePrivateKeyFile(path: string): Uint8Array;
    /**
     * Parses a file containing a secp256k1 public key
     * @param {string} path The path to the public key file
     * @returns A `Uint8Array` typed representation of the private key
     * @see {@link Secp256K1.parsePublicKey}
     */
    static parsePublicKeyFile(path: string): Uint8Array;
    /**
     * Parses a byte array containing a secp256k1 private key
     * @param {Uint8Array} bytes A private key as a byte array
     * @param {string} [originalFormat=der] The original format of the private key.
     * Options are "der" or "raw", meaning "derived" or "raw", indicating a seed phrase and
     * a raw private key respectively.
     * @returns A validated byte array containing the provided secp256k1 private key
     * @privateRemarks Validate that "der" means derived and "raw" means a raw private key
     */
    static parsePrivateKey(bytes: Uint8Array, originalFormat?: 'der' | 'raw'): Buffer;
    /**
     * Parses a byte array containing an Ed25519 public key
     * @param {Uint8Array} bytes A public key in bytes
     * @param {string} [originalFormat=der] The original format of the private key.
     * Options are "der" or "raw", meaning "derived" or "raw", indicating a seed phrase and
     * a raw private key respectively.
     * @returns A validated byte array containing the provided Ed25519 public key
     * @privateRemarks Validate that "der" means derived and "raw" means a raw public key
     */
    static parsePublicKey(bytes: Uint8Array, originalFormat?: 'der' | 'raw'): Uint8Array;
    /**
     * Calls global {@link readBase64WithPEM} and returns the result
     * @param {string} content A .pem private key string with a header and footer
     * @returns The result of global `readBase64WithPEM`
     * @see {@link readBase64WithPEM}
     */
    static readBase64WithPEM(content: string): Uint8Array;
    /**
     * Read the Base64 content of a file, ignoring PEM frames
     * @param {string} path The path to the PEM file
     * @returns The result of {@link Secp256K1.readBase64WithPEM} after reading in the content as a `string` with `fs`
     */
    private static readBase64File;
    /**
     * Convert this instance's private key to PEM format
     * @returns A PEM compliant string containing this instance's private key
     */
    exportPrivateKeyInPem(): string;
    /**
     * Convert this instance's public key to PEM format
     * @returns A PEM compliant string containing this instance's public key
     */
    exportPublicKeyInPem(): string;
    /**
     * Sign a message by using this instance's keypair
     * @param {Uint8Array} msg The message to be signed, as a byte array
     * @returns `Uint8Array` typed signature of the provided `msg`
     * @see [secp256k1.ecdsaSign](https://github.com/cryptocoinjs/secp256k1-node/blob/HEAD/API.md#ecdsasignmessage-uint8array-privatekey-uint8array--data-noncefn---data-uint8array-noncefn-message-uint8array-privatekey-uint8array-algo-null-data-uint8array-counter-number--uint8array----output-uint8array--len-number--uint8array--signature-uint8array-recid-number-)
     */
    sign(msg: Uint8Array): Uint8Array;
    /**
     * Verifies a signature given the signature and the original message
     * @param {Uint8Array} signature The signed message as a byte array
     * @param {Uint8Array} msg The original message as a byte array
     * @see [secp256k1.ecdsaVerify](https://github.com/cryptocoinjs/secp256k1-node/blob/HEAD/API.md#ecdsaverifysignature-uint8array-message-uint8array-publickey-uint8array-boolean)
     * @returns 'true' if the message if valid, `false` otherwise
     * @privateRemarks Need to document return and return type
     */
    verify(signature: Uint8Array, msg: Uint8Array): boolean;
    /**
     * Derive a public key from private key
     * @param {Uint8Array} privateKey The private key from which to derive the public key
     * @returns A `Uint8Array` public key generated deterministically from the provided private key
     * @see [secp256k1.publicKeyCreate](https://github.com/cryptocoinjs/secp256k1-node/blob/HEAD/API.md#publickeycreateprivatekey-uint8array-compressed-boolean--true-output-uint8array--len-number--uint8array--len--new-uint8arraylen-uint8array)
     */
    static privateToPublicKey(privateKey: Uint8Array): Uint8Array;
    /**
     * Restore secp256k1 keyPair from private key file
     * @param {string} privateKeyPath The path to the private key file
     * @returns A secp256k1 `AsymmetricKey`
     * @see {@link Secp256K1.parsePrivateKeyFile}
     * @see {@link Secp256K1.privateToPublicKey}
     * @see {@link Secp256K1.parseKeyPair}
     */
    static loadKeyPairFromPrivateFile(privateKeyPath: string): AsymmetricKey;
}
