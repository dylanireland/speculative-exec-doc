import { SignatureAlgorithm } from '../types';
export declare abstract class CasperHDKey<AsymmetricKey> {
    private seed;
    private signatureAlorithm;
    static readonly bip44Index = 506;
    constructor(seed: Uint8Array, signatureAlorithm: SignatureAlgorithm);
    static bip44Path(index: number): string;
    /**
     * Returns mnemonic which can be used to construct HD wallet.
     * @param wordLength mnemonic word length, default 12, possible lengths 12 or 24
     * @returns mnemonic word array
     */
    static newMnemonic(wordLength?: number): string;
    /**
     * Validate the mnemonic word array
     * @param mnemonic word array
     * @returns `true` if the word array is correct mnemonic, otherwise `false`
     */
    static validateMnemonic(mnemonic: string): boolean;
    /**
     * Convert mnemonic to relevant `Uint8Array`
     * @param mnemonic word array
     * @returns relevant `Uint8Array`
     */
    static mnemonicToSeed(mnemonic: string): Uint8Array;
    /**
     * Returns randomly generated `Uint8Array` which can be used to construct HD wallet.
     * @returns
     */
    static newSeed(): Uint8Array;
    /**
     * Set provided word list as default word list
     * @param list
     */
    static setWordlist(list: string[]): void;
    /**
     * Returns word list
     * @default english word list
     * @returns word list
     */
    static getWordlist(): string[];
    /**
     * Returns english word list
     * @returns word list
     */
    static getDefaultWordlist(): string[];
    /**
     * Returns SignatureAlgorithm
     */
    get signatureAlgorithm(): SignatureAlgorithm;
    /**
     * Returns current wallet's mnemonic
     */
    get mnemonic(): string;
    /**
     * Derive the child key based on BIP44
     * @param index index of the child
     */
    deriveChild(index: number): AsymmetricKey;
    /**
     * Derive the child key from the path
     * @param path path to derive
     */
    abstract derive(path: string): AsymmetricKey;
    /**
     * Generate the signature for the message by using the key
     * @param msg The message to sign
     */
    abstract sign(msg: Uint8Array): Uint8Array;
    /**
     * Verify the signature
     * @param signature the signature generated for the msg
     * @param msg the raw message
     */
    abstract verify(signature: Uint8Array, msg: Uint8Array): boolean;
    /**
     * Returns public key of the default HD wallet
     */
    abstract publicKey(): Uint8Array;
    /**
     * Returns private key of the default HD wallet
     */
    abstract privateKey(): Uint8Array;
}
